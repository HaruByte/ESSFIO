/**
 * @file
 * This is the main script for publishing the frame.
 * It should be executed using cronjob or something that has intervally execution.
 * Needs ShareX config file (configs/uploader.sxcu) and data from create.js (configs/data.json)
 * to works properly.
 * 
 * @author AozoraDev
 */

const fs = require("fs");
const create = require("./create.js");
const util = require("./utils/util.js");

require("dotenv").config();
require("./utils/console.js");

/* Main Variables */
/** @const {string} dataPath - Path to data.json */
const dataPath = "configs/data.json";
/** @var {?Object} data - A object of data file that generated by create.js */
let data = JSON.parse(fs.readFileSync(dataPath, { encoding: "utf8" }));

/* Main function */
(main = async () => {
    /** @const {number} current_frame - Current frame */
    const current_frame = data.current_frame;
    /** @const {string} frameWithPad - Current frame with format "XXXX" */
    const frameWithPad = util.addNumberPad(current_frame, 4);
    /** @const {string} episodeWithPad - Current episode with format "XX" */
    const episodeWithPad = util.addNumberPad(data.current_episode, 2);
    
    // All frames already published.
    // Try either creating new data.json from next episode,
    // or stop the program.
    if (current_frame > data.max_frame) {
        console.warn("Episode " + episodeWithPad + " is completed! Checking new anime...");
        
        // No more episode available, end the program.
        if (data.current_episode >= data.max_episode) {
            console.log("No more episode available. I think that's the end.");
            process.exit(0);
        }
        
        // Still has more episode (maybe), call create to create new data.json
        create(
            data.current_episode + 1,
            data.max_episode,
            data.enable_duplicate_detection
        );
        // Update data variable
        data = JSON.parse(fs.readFileSync(dataPath, { encoding: "utf8" }));
        // Then call main, ofc.
        main();
        return;
    }
    
    /** @const {string} fileName - Full file name of the frame */
    const fileName = `${episodeWithPad}_${frameWithPad}.jpeg`;
    /** @const {string} framePath - Path to the frame file */
    const framePath = `frames/${fileName}`;
    
    // If current frame file is missing, call main again to try to post another frame.
    if (!fs.existsSync(framePath)) {
        console.warn(fileName + " is not exist. Trying another next frame...");
        
        // Update data variable
        updateData();
        data = JSON.parse(fs.readFileSync(dataPath, { encoding: "utf8" }));
        
        main();
        return;
    }
    
    // Frames duplication detection (if enabled)
    /** @var {number} skippedFrames - Total of how much frames is skipped due to duplication */
    let skippedFrames = 0;
    
    if (data.enable_duplicate_detection) {
        console.log("Duplicate detection is enabled. Detecting duplication...");
        
        /** @var {string} nextFrame - Next frame with format "XXXX" */
        let nextFrame = util.addNumberPad(current_frame + 1, 4);
        /** @var {string} nextFrameName - Filename of the next frame */
        let nextFrameName = `${episodeWithPad}_${nextFrame}.jpeg`;
        
        // Keep looping until no more duplicate detected.
        while (await util.detectDuplicate(framePath, "frames/" + nextFrameName)) {
            console.warn(`${nextFrameName} is a duplicate of ${fileName}.`);
            
            // Delete duplicate
            fs.unlinkSync("frames/" + nextFrameName);
            // Plus 1 the skipped frames variable
            skippedFrames++;
            // Update the next frame variable
            nextFrame = util.addNumberPad(parseInt(nextFrame) + 1, 4);
            nextFrameName = `${episodeWithPad}_${nextFrame}.jpeg`;
        }
        
        console.log("Detection is finished.");
    }
    
    // Caption for post
    const caption = 
        `Episode ${episodeWithPad}` // Episode
        + " - "
        + `Frame ${current_frame} out of ${data.max_frame}` // Frame
        + ((skippedFrames) ? `\n${skippedFrames} frame${(skippedFrames > 1) ? "s" : ""} will be skipped in the next post.\n` : "\n") // Skipped frame
        + `#ESSFIOEPS${data.current_episode}`; // Unique tag
    
    // for Facebook
    const published = (process.env.PUBLISHED != undefined)
        ? String(process.env.PUBLISHED) // For debugging because it will always false, otherwise if you change it to true.
        : "true"; // PUBLISHED not exist or null, just use true.
    
    const formData = new FormData();
    const img = await util.uploadImage(framePath, fileName);
    
    formData.append("access_token", process.env.TOKEN); // Facebook Page access token
    formData.append("published", published);
    formData.append("url", img.url + ".jpeg");
    formData.append("caption", caption);
    
    // Create new feed on Facebook Page
    console.log(`Episode ${episodeWithPad} - Frame ${current_frame}/${data.max_frame} is publishing...`);
    const res = await fetch(`https://graph.facebook.com/v18.0/me/photos`, {
        body: formData,
        method: "post"
    }).then(r => r.json());
    if (res.error) throw new Error(res.error.message);
    
    console.log(`Episode ${episodeWithPad} - Frame ${current_frame}/${data.max_frame} published!`);
    if (formData.get("published") == "false") console.log("Nah jk. It's not published lol.");
    
    // Update data
    updateData(skippedFrames);
    // Delete the current frame file and in the sxcu server
    fs.unlinkSync(framePath);
    await fetch(img.del_url)
        .catch(() => console.error("Failed to delete image from ShareX server."));
    
    // Sometimes the program keep running even after publishing the post.
    // So we have to explicitly exit the program.
    process.exit(0);
})();

/**
 * Plus 1 the current frame and then save the data.json file
 * 
 * @param {?number} sum - The sum of the frames added
 * @returns {void}
 * @throws {Error}
 */
function updateData(sum) {
    if (sum) {
        data.current_frame += (sum + 1);
    } else {
        data.current_frame++;
    }
    
    fs.writeFileSync(dataPath, JSON.stringify(data, null, 2));
}