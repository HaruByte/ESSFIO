/**
 * @file
 * This is the main script for publishing the frame.
 * It should be executed using cronjob or something that has intervally execution.
 * Needs ShareX config file (configs/uploader.sxcu) and data from create.js (configs/data.json)
 * to works properly.
 * 
 * @author AozoraDev
 */

const fs = require("fs");
const create = require("./create.js");
const { HashAlgorithm, hammingDistance } = require("img-hasher");

require("dotenv").config();
require("./utils/console.js");

/* Main Variables */
/** @const {string} dataPath - Path to data.json */
const dataPath = "configs/data.json";
/** @var {?Object} data - A object of data file that generated by create.js */
let data = JSON.parse(fs.readFileSync(dataPath, { encoding: "utf8" }));
/** @const {?Object} sxcu - A object of ShareX config file */
const sxcu = JSON.parse(fs.readFileSync("configs/uploader.sxcu", { encoding: "utf8" }));

/* Main function */
(main = async () => {
    /** @const {number} current_frame - Current frame */
    const current_frame = data.current_frame;
    /** @const {string} frameWithPad - Current frame with format "XXXX" */
    const frameWithPad = current_frame.toString().padStart(4, "0");
    /** @const {string} episodeWithPad - Current episode with format "XX" */
    const episodeWithPad = data.current_episode.toString().padStart(2, "0");
    
    // All frames already published.
    // Try either creating new data.json from next episode,
    // or stop the program.
    if (current_frame > data.max_frame) {
        console.warn("Episode " + episodeWithPad + " is completed! Checking new anime...");
        
        // No more episode available, end the program.
        if (data.current_episode >= data.max_episode) {
            console.log("No more episode available. I think that's the end.");
            process.exit(0);
        }
        
        // Still has more episode (maybe), call create to create new data.json
        create(
            data.current_episode + 1,
            data.max_episode,
            data.enable_duplicate_detection
        );
        // Update data variable
        data = JSON.parse(fs.readFileSync(dataPath, { encoding: "utf8" }));
        // Then call main, ofc.
        main();
        return;
    }
    
    /** @const {string} fileName - Full file name of the frame */
    const fileName = `${episodeWithPad}_${frameWithPad}.jpeg`;
    /** @const {string} framePath - Path to the frame file */
    const framePath = `frames/${fileName}`;
    
    // If current frame file is missing, call main again to try to post another frame.
    if (!fs.existsSync(framePath)) {
        console.warn(fileName + " is not exist. Trying another next frame...");
        
        // Update data variable
        updateData();
        data = JSON.parse(fs.readFileSync(dataPath, { encoding: "utf8" }));
        
        main();
        return;
    }
    
    // Frames duplication detection (if enabled)
    /** @var {number} skippedFrames - Total of how much frames is skipped due to duplication */
    let skippedFrames = 0;
    
    if (data.enable_duplicate_detection) {
        console.log("Duplicate detection is enabled. Detecting duplication...");
        
        /** @var {string} nextFrame - Next frame with format "XXXX" */
        let nextFrame = (data.current_frame + 1)
            .toString()
            .padStart(4, "0");
        /** @var {string} nextFrameName - Filename of the next frame */
        let nextFrameName = `${episodeWithPad}_${nextFrame}.jpeg`;
        
        // Keep looping until no more duplicate detected
        while (await detectDuplicate(framePath, "frames/" + nextFrameName)) {
            console.warn(`${nextFrameName} is a duplicate of ${fileName}.`);
            
            // Delete duplicate
            fs.unlinkSync("frames/" + nextFrameName);
            // Plus 1 the skipped frames variable
            skippedFrames++;
            // Update data and the next frame variable
            updateData();
            nextFrame = (data.current_frame + 1)
                .toString()
                .padStart(4, "0");
            nextFrameName = `${episodeWithPad}_${nextFrame}.jpeg`;
        }
        
        console.log("Detection is finished.");
    }
    
    // Caption for post
    const caption = 
        `Episode ${episodeWithPad}` // Episode
        + " - "
        + `Frame ${current_frame} out of ${data.max_frame}` // Frame
        + ((skippedFrames) ? `\n${skippedFrames} frame${(skippedFrames > 1) ? "s" : ""} will be skipped in the next post.\n` : "\n") // Skipped frame
        + `#ESSFIOEPS${data.current_episode}`; // Unique tag
    
    // for Facebook
    const published = (process.env.PUBLISHED != undefined)
        ? String(process.env.PUBLISHED) // For debugging because it will always false, otherwise if you change it to true.
        : "true"; // PUBLISHED not exist or null, just use true.
    
    const formData = new FormData();
    formData.append("access_token", process.env.TOKEN); // Facebook Page access token
    formData.append("published", published);
    formData.append("url", await uploadImage(framePath, fileName));
    formData.append("caption", caption);
    
    // Create new feed on Facebook Page
    console.log(`Episode ${episodeWithPad} - Frame ${current_frame}/${data.max_frame} is publishing...`);
    const res = await fetch(`https://graph.facebook.com/v18.0/me/photos`, {
        body: formData,
        method: "post"
    }).then(r => r.json());
    if (res.error) throw new Error(res.error.message);
    
    console.log(`Episode ${episodeWithPad} - Frame ${current_frame}/${data.max_frame} published!`);
    if (formData.get("published") == "false") console.log("Nah jk. It's not published lol.");
    
    // Update data
    updateData();
    // Delete the current frame file
    fs.unlinkSync(framePath);
})();

/**
 * Plus 1 the current frame and then save the data.json file
 * 
 * @returns {void}
 * @throws {Error}
 */
function updateData() {
    data.current_frame++;
    fs.writeFileSync(dataPath, JSON.stringify(data, null, 2));
}

/**
 * Upload a image to ShareX server with output format jpeg
 * 
 * @async
 * @param {string} path - Path to the image file
 * @param {string=} fileName - File name for the image file
 * @returns {Promise<string>} URL to the uploaded image file
 * @throws {Error}
 */
async function uploadImage(path, fileName) {
    const file = fs.readFileSync(path);
    const sxcuData = new FormData();
    
    sxcuData.append(sxcu.FileFormName, new Blob([file]), fileName || "file.jpeg");
    if (sxcu.Arguments) for (const prop in sxcu.Arguments) {
        sxcuData.append(prop, sxcu.Arguments[prop]);
    }
    
    // Upload frame file to ShareX server
    const res = await fetch(sxcu.RequestURL, {
        method: sxcu.RequestMethod || "POST",
        body: sxcuData
    }).then(r => r.json());
    
    // The fetch should throw error, but this one is just in case.
    if (!res.url) throw new Error("URL output is not exist");
    
    return res.url + ".jpeg";
}

/**
 * Detect duplication between two images by using hashing.
 * Mean Algorithm is used in this hashing
 *
 * @async
 * @param {string} file1 - Path to the first file
 * @param {string} file2 - Path to the second file
 * @returns {Promise<boolean>} true if duplication is detected, false if not duplication.
 */
async function detectDuplicate(file1, file2) {
    const distance = await hammingDistance(
        fs.readFileSync(file1),
        fs.readFileSync(file2),
        HashAlgorithm.Mean
    );
    
    return (distance == 0); // 0 means there's a duplication detected
}